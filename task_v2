<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title >Non-Spatial Navigation Task</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: rgb(80, 80, 80);
            text-align: center;
            overflow: hidden;

        }
        
        .container {
            max-width: 100%;
            margin: 0;
            background: rgb(80, 80, 80);
            padding: 0;
            border-radius: 0;
            box-shadow: none;
        }
        
        .header {
            padding: 8px;
            margin: 5px;
            /* border: 1px solid #808080; */
            border-radius: 4px;
            font-size: 40px;
        }

        .demographics {
            margin: 20px auto;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
            max-width: 600px;
            background: white;
        }
        
        .demographics input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .demographics button {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
        }
        
        .demographics button:hover {
            background: #45a049;
        }
        
        .task-container {
            display: none;
            margin: 0;
            padding: 0;
        }
        
        .task-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgb(255, 255, 255);
            z-index: 1000;
            margin: 0;
            padding: 0;
        }
        
        .task-container.fullscreen h1,
        .task-container.fullscreen .instructions,
        .task-container.fullscreen .progress,
        .task-container.fullscreen .demographics {
            display: none;
        }
        
        .task-container.fullscreen .container h1 {
            display: none;
        }
        
        /* Ensure feedback is visible in fullscreen when shown */
        .task-container.fullscreen .feedback.show {
            display: block !important;
        }
        
        .stimulus-display {
            position: relative;
            width: 1470px;
            height: 956px;
            margin: 0;
            border: none;
            background: rgb(80, 80, 80);
        }
        
        .stimulus {
            position: absolute;
            border-radius: 50%;
            border: 2px solid black;
        }
        
        .stimulus.pie {
            background: conic-gradient(from 0deg, black 0deg 90deg, white 90deg 360deg);
        }
        
        .stimulus.circle {
            background: white;
        }
        
        .choice-display {
            display: none;
            margin: 0;
            position: absolute;
            bottom: 100px;
            z-index: 1000;
        }
        
        .demo-title {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }
        
        .start-experiment-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            z-index: 1000;
            display: none;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            border: 3px solid #4CAF50;
        }
        
        .choice-option {
            display: inline-block;
            margin: 0 20px;
            cursor: pointer;
            padding: 15px 30px;
            border: 3px solid #333;
            border-radius: 10px;
            transition: all 0.3s;
            background: rgb(255, 255, 255);
            font-size: 24px;
            font-weight: bold;
            color: #333;
            min-width: 80px;
            text-align: center;
        }
        
        .choice-option:hover {
            border-color: #4CAF50;
            background: #4CAF50;
            color: white;
            transform: scale(1.05);
        }
        
        .choice-option.selected {
            border-color: #4CAF50;
            background: #4CAF50;
            color: white;
        }
        
        .instructions {
            font-size: 18px;
            margin: 20px 0;
            padding: 20px;
            background: #e8f4f8;
            border-radius: 8px;
        }
        
        .feedback {
            font-size: 48px;
            font-weight: bold;
            margin: 0;
            padding: 40px;
            border-radius: 15px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            min-width: 300px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none; /* Hidden by default */
        }
        
        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .progress {
            margin: 20px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 8px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .break-screen {
            display: none;
            font-size: 24px;
            margin: 50px 0;
            padding: 40px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
        }
        
        .break-screen button {
            background: #007bff;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            margin: 20px;
        }
        
        .break-screen button:hover {
            background: #0056b3;
        }
        
        .completion {
            display: none;
            font-size: 24px;
            margin: 50px 0;
            padding: 40px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            color: #155724;
            text-align: center;
        }
        
        .download-button {
            background: #007bff;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            margin: 20px;
            transition: all 0.3s;
        }
        
        .download-button:hover {
            background: #0056b3;
            transform: scale(1.05);
        }
        
        .download-button:active {
            transform: scale(0.95);
        }
        

    </style>
</head>
<body>
    <div class="container">
        <div id = 'header' class = 'header'>
            <h1 >Non-Spatial Navigation Task</h1>
        </div>
        <!-- Demographics Section -->
        <div id="demographics" class="demographics">
            <h2>Participant Information</h2>
            <div>
                <label for="participantNumber">Participant Number:</label>
                <input type="text" id="participantNumber" placeholder="Enter participant number" required>
            </div>
            <div>
                <label for="age">Age:</label>
                <input type="number" id="age" placeholder="Enter age" min="18" max="100" required>
            </div>
            <button onclick="startTask()">Start Task</button>
        </div>
        
        <!-- Task Container -->
        <div id="taskContainer" class="task-container">
            <!-- Instructions -->
            <div id="instructions" class="instructions">
                <h3>Task Instructions</h3>
                <p>You will see a sequence of 3 pie-shaped stimuli. After the sequence, you need to predict which of two options will be the next stimulus.</p>
                <p>Use the <strong>Z</strong> key for the left option and <strong>X</strong> key for the right option.</p>
                <p>Press any key to continue...</p>
            </div>
            
            <!-- Demo Title -->
            <div id="demoTitle" class="demo-title">Example Trial</div>
            
            <!-- Start Experiment Text -->
            <div id="startExperimentText" class="start-experiment-text">Press Enter to Start Experiment</div>
            
            <!-- Stimulus Display -->
            <div id="stimulusDisplay" class="stimulus-display">
                <div id="stimulusCanvas"></div>
            </div>
            
            <!-- Choice Display -->
            <div id="choiceDisplay" class="choice-display">
                <div class="choice-option" data-key="z">
                    <strong>Z</strong>
                </div>
                <div class="choice-option" data-key="x">
                    <strong>X</strong>
                </div>
            </div>
            
            <!-- Feedback -->
            <div id="feedback" class="feedback" style="display: none;"></div>
            
            <!-- Progress -->
            <div class="progress">
                <div>Block <span id="currentBlock">1</span> of 2 - Trial <span id="currentTrial">1</span> of <span id="totalTrials">1</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
        
        <!-- Break Screen -->
        <div id="breakScreen" class="break-screen">
            <h2>Break Between Blocks</h2>
            <p>You have completed Block 1. Take a short break.</p>
            <p>Press the button below when you're ready to continue with Block 2.</p>
            <button onclick="continueToBlock2()">Continue to Block 2</button>
        </div>
        
        <!-- Completion Screen -->
        <div id="completion" class="completion">
            <h2>Task Completed!</h2>
            <p>Thank you for your participation.</p>
            <p>Your response data has been collected and is ready for download.</p>
            <button id="downloadData" class="download-button" onclick="downloadData()">
                📥 Download Response Data
            </button>
            <p style="font-size: 16px; margin-top: 20px; color: #666;">
                Click the button above to download your data as a JSON file.
            </p>
        </div>
    </div>

    <script>
        // Global variables
        let participantData = {};
        let currentBlock = 1;
        let currentTrial = 0;
        let totalTrials = 0;
        let trialData = [];
        let block1Data = { size: [], ori: [] };
        let block2Data = [];
        let block1Conditions = [];
        let block2Conditions = [];
        
        // Task parameters
        const maxStimSize = 300;
        const minStimSize = 60;
        const setStepSize = { low: 1.5, med: 1.55, high: 1.6 };
        const setChoiceSize = { near: 1.3, far: 1.4 };
        const setChoiceEst = { under: -1, over: 1 };
        const setDirection = {forward:1,backward:-1}
        const setStepOri = { low: 40, med: 45, high: 50 };
        const setChoiceOri = { near: 25, far: 35 };
        const setStepDist = { low: 30, med: 40, high: 50 };
        const setChoiceDist = { near: 0.5, far: 0.8 };
        
        // Utility functions
        function randint(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }
        
        function choice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // function createPie(container, radius, startAngle, position) {
        //     const pie = document.createElement('div');
        //     pie.className = 'stimulus pie';
        //     pie.style.width = radius * 2 + 'px';
        //     pie.style.height = radius * 2 + 'px';
        //     pie.style.left = (position[0] - radius) + 'px';
        //     pie.style.top = (position[1] - radius) + 'px';
        //     pie.style.transform = `rotate(${startAngle}deg)`;
        //     container.appendChild(pie);
        //     return pie;
        // }

        // function createPie(container, radius, startAngle, position) {
        //     const pie = document.createElement('div');
        //     pie.className = 'stimulus pie';
        //     pie.style.width = radius * 2 + 'px';
        //     pie.style.height = radius * 2 + 'px';
        //     pie.style.left = (position[0] - radius) + 'px';
        //     pie.style.top = (position[1] - radius) + 'px';
        //     pie.style.borderRadius = '50%';

        //     // Use conic-gradient to make a wedge
        //     pie.style.background = `conic-gradient(
        //         red ${startAngle}deg ${startAngle + 30}deg,
        //         transparent ${startAngle + 30}deg 360deg
        //     )`;

        //     container.appendChild(pie);
        //     return pie;
        // }

        function createPie(container, radius, orientation, position) {
            const pie = document.createElement('div');
            pie.className = 'stimulus pie';
            pie.style.width = radius * 2 + 'px';
            pie.style.height = radius * 2 + 'px';
            pie.style.left = (position[0] - radius) + 'px';
            pie.style.top = (position[1] - radius) + 'px';
            pie.style.transform = `rotate(${orientation}deg)`;
            container.appendChild(pie);
            return pie;
        }
        
        
        function createCircle(container, radius, position) {
            const circle = document.createElement('div');
            circle.className = 'stimulus circle';
            circle.style.width = radius * 2 + 'px';
            circle.style.height = radius * 2 + 'px';
            circle.style.left = (position[0] - radius) + 'px';
            circle.style.top = (position[1] - radius) + 'px';
            container.appendChild(circle);
            return circle;
        }
        
        function clearStimulusDisplay() {
            const container = document.getElementById('stimulusCanvas');
            container.innerHTML = '';
        }
        
        function showStimulus(radius, orientation, duration = 1000) {
            return new Promise((resolve) => {
                clearStimulusDisplay();
                const container = document.getElementById('stimulusCanvas');
                const pie = createPie(container, radius, orientation, [735, 478]); // Center of 1470x956 screen
                
                setTimeout(() => {
                    clearStimulusDisplay();
                    resolve();
                }, duration);
            });
        }
        
        function showChoice(leftRadius, leftOri, rightRadius, rightOri, positions) {
            return new Promise((resolve) => {
                clearStimulusDisplay();
                const container = document.getElementById('stimulusCanvas');
                
                // Convert screen coordinates to display coordinates
                const leftPos = [positions[0][0] + 735, 478]; // 735 is screen center X
                const rightPos = [positions[1][0] + 735, 478]; // 735 is screen center X
                
                createPie(container, leftRadius, leftOri, leftPos);
                createPie(container, rightRadius, rightOri, rightPos);
                
                // Position choice buttons at the same x-coordinates as stimuli
                const choiceDisplay = document.getElementById('choiceDisplay');
                const leftButton = choiceDisplay.querySelector('[data-key="z"]');
                const rightButton = choiceDisplay.querySelector('[data-key="x"]');
                
                // Position left button (Z) at left stimulus x-coordinate
                leftButton.style.position = 'absolute';
                // leftButton.style.left = -367.5+ 735+ 'px';
                leftButton.style.left = '367.5px';
                leftButton.style.transform = 'translateX(-50%)';
                
                // Position right button (X) at right stimulus x-coordinate
                rightButton.style.position = 'absolute';
                rightButton.style.left = '1102.5px';
                rightButton.style.transform = 'translateX(-50%)';
                
                // Show choice buttons
                choiceDisplay.style.display = 'block';
                
                // Start reaction time measurement
                const startTime = performance.now();
                
                const handleKeyPress = (event) => {
                    if (event.key.toLowerCase() === 'z' || event.key.toLowerCase() === 'x') {
                        const endTime = performance.now();
                        const reactionTime = endTime - startTime; // in milliseconds
                        
                        document.removeEventListener('keydown', handleKeyPress);
                        choiceDisplay.style.display = 'none';
                        clearStimulusDisplay();
                        resolve({
                            key: event.key.toLowerCase(),
                            reactionTime: reactionTime
                        });
                    }
                };
                
                document.addEventListener('keydown', handleKeyPress);
            });
        }
        
        function showFeedback(isCorrect, duration = 500) {
            return new Promise((resolve) => {
                const feedback = document.getElementById('feedback');
                feedback.textContent = isCorrect ? 'Correct!' : 'Incorrect';
                feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                
                // Show feedback
                feedback.style.display = 'block';
                feedback.classList.add('show');
                
                setTimeout(() => {
                    // Hide feedback
                    feedback.style.display = 'none';
                    feedback.classList.remove('show');
                    resolve();
                }, duration);
            });
        }
        
        function updateProgress() {
            document.getElementById('currentBlock').textContent = currentBlock;
            document.getElementById('currentTrial').textContent = currentTrial + 1;
            document.getElementById('totalTrials').textContent = totalTrials;
            
            const progress = ((currentTrial + 1) / totalTrials) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }
        
        // Block 1 functions
        function generateBlock1Conditions() {
            const dimension = ['size', 'ori'];
            const stepSize = ['low', 'med', 'high'];
            const choiceDist = ['near', 'far'];
            const choiceEst = ['under', 'over'];
            const direction = ['forward', 'backward'];
            
            let conditions = [];
            for (let d of dimension) {
                for (let ss of stepSize) {
                    for (let cd of choiceDist) {
                        for (let ce of choiceEst) {
                            for (let dir of direction) {
                                conditions.push([d, ss, cd, ce, dir]);
                            }
                        }
                    }
                }
            }
            
            // Repeat 5 times
            conditions = Array(5).fill(conditions).flat();
            return shuffle(conditions);
        }
        
        function listRadius(step,direction) {
            let stim, dirR;
            let start = true;
            while (start) {
                stim = [];
                let initR = randint(60, 300);
                dirR = direction;
                for (let i = 0; i < 4; i++) {
                    let r = initR * Math.pow(step, i * dirR);
                    r = Math.round(r * 10000) / 10000;
                    stim.push(r);
                }
                if (stim.every(x => minStimSize < x && x < maxStimSize)) {
                    start = false;
                }
            }
            return stim;
        }
        
        function rotateOri(step, direction) {
            let stim = [];
            let initOri = randint(0, 360);
            let dirOri = direction;
            for (let i = 0; i < 4; i++) {
                let r = initOri + step * dirOri * i;
                stim.push(r%360);
            }
            return stim;
        }
        
        async function runBlock1Trial(condition) {
            const [dimension, stepLevel, choiceDist, choiceEst, direction] = condition;
            
            if (dimension === 'size') {
                const step = setStepSize[stepLevel];
                const dir = setDirection[direction];
                const stimR = listRadius(step,dir);
                const stimOri = randint(0, 360);
                
                

                // Show sequence of 3 stimuli
                for (let i = 0; i < 3; i++) {
                    await showStimulus(stimR[i], stimOri);
                }

                // Generate foil
                const choiceDeviate = setChoiceSize[choiceDist];
                const choiceDir = setChoiceEst[choiceEst];
                const foilR = stimR[3] * Math.pow(choiceDeviate, (choiceDir * dir));
                const foilOri = stimOri;
                
                // Randomize positions (matching Python coordinates)
                const positions = [[-367.5, "z"], [367.5, "x"]]; // -0.5*screen_w/2 and 0.5*screen_w/2
                shuffle(positions);
                
                // Show choice
                const choiceResult = await showChoice(stimR[3], stimOri, foilR, foilOri, positions);
                const choice = choiceResult.key;
                const reactionTime = choiceResult.reactionTime;
                
                // Determine if correct
                const isCorrect = (choice === positions[0][1]); 
                
                await showFeedback(isCorrect, 500);

                console.log(foilR, positions)
                console.log(choice)


                // Store data
                block1Data.size.push({
                    stimulus_radius: stimR,
                    stimulus_orientation: stimOri,
                    distance: step,
                    direction: dir,
                    choice_distance: choiceDeviate,
                    choice_estimate: choiceEst,
                    foil_radius: foilR,
                    foil_orientation: foilOri,
                    rt: reactionTime,
                    correct_ans: isCorrect ? 1 : 0
                });
                
            } else if (dimension === 'ori') {
                const step = setStepOri[stepLevel];
                const stimR = randint(40, 300);
                const dir = setDirection[direction];
                const stimOri = rotateOri(step,dir);
                
                
                console.log(stimOri)
                // Show sequence of 3 stimuli
                for (let i = 0; i < 3; i++) {
                    await showStimulus(stimR, stimOri[i]);
                }
                
                

                // Generate foil
                const choiceDeviate = setChoiceOri[choiceDist];
                const choiceDir = setChoiceEst[choiceEst];
                const foilR = stimR;
                const foilOri = (stimOri[3] + choiceDeviate * choiceDir * dir) % 360;
                
                // Randomize positions (matching Python coordinates)
                const positions = [[-367.5, "z"], [367.5, "x"]]; // -0.5*screen_w/2 and 0.5*screen_w/2
                shuffle(positions);
                
                // Show choice
                const choiceResult = await showChoice(stimR, stimOri[3], foilR, foilOri, positions);
                const choice = choiceResult.key;
                const reactionTime = choiceResult.reactionTime;
                
                // Determine if correct
                const isCorrect = (choice === positions[0][1]); 
                
                await showFeedback(isCorrect, 500);


                console.log(foilOri, positions)
                console.log(choice)

                // Store data
                block1Data.ori.push({
                    stimulus_radius: stimR,
                    stimulus_orientation: stimOri,
                    distance: step,
                    direction: dir,
                    choice_distance: choiceDeviate,
                    choice_estimate: choiceEst,
                    foil_radius: foilR,
                    foil_orientation: foilOri,
                    rt: reactionTime,
                    correct_ans: isCorrect ? 1 : 0
                });
            }
        }
        
        // Block 2 functions
        function generateBlock2Conditions() {
            const stepSize = ['low', 'med', 'high'];
            const choiceDist = ['near', 'far'];
            const choiceEst = ['under', 'over'];
            const direction = ['forward', 'backward'];
            
            let conditions = [];
            for (let ss of stepSize) {
                for (let cd of choiceDist) {
                    for (let ce of choiceEst) {
                        for (let dir of direction) {
                            conditions.push([ss, cd, ce, dir]);
                        }
                    }
                }
            }
            
            // Repeat 10 times
            conditions = Array(10).fill(conditions).flat();
            return shuffle(conditions);
        }
        
        function genStimCoord(step) {
            while (true) {
                const m = (Math.random() - 0.5) * 3 / 50;
                const c = (Math.random() * 90 + 10) / 10;
                const x1 = Math.random() * 160 + 40;
                
                const orientation = [x1, x1 + step, x1 + 2 * step, x1 + 3 * step];
                const size = orientation.map(x => Math.exp(m * x + c));
                
                const sizeSteps = [];
                for (let i = 0; i < size.length - 1; i++) {
                    sizeSteps.push(Math.abs(size[i + 1] - size[i]));
                }
                
                if (sizeSteps.every(delta => delta >= 15) && 
                    size.every(y => 60 <= y && y <= 240)) {
                    return [m, c, size.map((s, i) => [s, orientation[i]])];
                }
            }
        }
        
        function findDistance(stimR, stimOri) {
            const logR = stimR.map(r => Math.log(r));
            const distance = Math.sqrt(
                Math.pow(logR[1] - logR[0], 2) + 
                Math.pow(stimOri[1] - stimOri[0], 2)
            );
            return [distance, logR];
        }
        
        function findNextPoint(m, c, targetOri, distance, deviate, direction, est) {
            const dist = distance * deviate;
            const deltaOri = dist / Math.sqrt(1 + m * m);
            const ori2Pos = targetOri + deltaOri;
            const ori2Neg = targetOri - deltaOri;
            
            const r2Pos = m * ori2Pos + c;
            const r2Neg = m * ori2Neg + c;
            
            if (direction === 'forward') {
                if (est === 'over') {
                    return [ori2Pos % 360, r2Pos];
                } else {
                    return [ori2Neg % 360, r2Neg];
                }
            } else {
                if (est === 'over') {
                    return [ori2Neg % 360, r2Neg];
                } else {
                    return [ori2Pos % 360, r2Pos];
                }
            }
        }
        
        async function runBlock2Trial(condition, stimCoord, stimSlope, stimIntc, stimDist, stimDirX) {
            const [stepLevel, choiceDist, choiceEst, direction] = condition;
            const step = setStepDist[stepLevel];
            
            const currStimR = stimCoord.map(x => x[0]);
            const currStimOri = stimCoord.map(x => x[1] % 360);
            const currStimSlope = stimSlope;
            const currStimIntc = stimIntc;
            const currStimDist = stimDist;
            const currStimDirX = stimDirX;
            const currStimDir = direction;
    
            
            // Show sequence of 3 stimuli
            for (let i = 0; i < 3; i++) {
                await showStimulus(currStimR[i], currStimOri[i]);
            }
            

            // Generate foil
            const choiceDeviate = setChoiceDist[choiceDist];
            const choiceEstValue = choiceEst;
            
            const [distance, logR] = findDistance(currStimR, currStimOri);
            const [foilOri, foilLogRadius] = findNextPoint(
                currStimSlope, currStimIntc, currStimOri[3], 
                distance, choiceDeviate, currStimDir, choiceEstValue
            );
            const foilR = Math.exp(foilLogRadius);
            
            // Randomize positions (matching Python coordinates)
            const positions = [[-367.5, "z"], [367.5, "x"]]; // -0.5*screen_w/2 and 0.5*screen_w/2
            shuffle(positions);
            
            // Show choice
            const choiceResult = await showChoice(currStimR[3], currStimOri[3], foilR, foilOri, positions);
            const choice = choiceResult.key;
            const reactionTime = choiceResult.reactionTime;
            
            // Determine if correct
            const isCorrect = (choice === positions[0][1]); 
            
            await showFeedback(isCorrect, 500);
            
            // Store data
            block2Data.push({
                stimulus_radius: currStimR,
                stimulus_log_radius: logR,
                stimulus_orientation: currStimOri,
                stimulus_slope: currStimSlope,
                stimulus_intc: currStimIntc,
                distance: currStimDist,
                direction: currStimDirX,
                choice_distance: choiceDeviate,
                choice_estimate: choiceEstValue,
                foil_radius: foilR,
                foil_log_radius: foilLogRadius,
                foil_orientation: foilOri,
                rt: reactionTime,
                correct_ans: isCorrect ? 1 : 0
            });
        }
        
        // Demo trial function
        async function runDemoTrial() {
            // Show demo instructions
            const instructions = document.getElementById('instructions');
            instructions.innerHTML = `
                <h3>Demo Trial</h3>
                <p>This is a practice trial to help you understand the task.</p>
                <p>You will see 3 stimuli, then choose between two options.</p>
                <p>Press any key to start the demo...</p>
            `;
            
            // // Wait for key press
            // await new Promise(resolve => {
            //     const handleKeyPress = () => {
            //         document.removeEventListener('keydown', handleKeyPress);
            //         resolve();
            //     };
            //     document.addEventListener('keydown', handleKeyPress);
            // });
            
            // Show demo title
            document.getElementById('demoTitle').style.display = 'block';
            
            // Demo stimulus sequence (simple size progression)
            const demoRadii = [100, 120, 140];
            const demoOri = 45;
            
            for (let i = 0; i < 3; i++) {
                await showStimulus(demoRadii[i], demoOri, 800);
            }
            
            // Demo choice (correct vs incorrect)
            const correctRadius = 160;
            const incorrectRadius = 180;
            const positions = [[-367.5, "z"], [367.5, "x"]];
            
            const choiceResult = await showChoice(correctRadius, demoOri, incorrectRadius, demoOri, positions);
            const choice = choiceResult.key;
            
            // Show feedback
            const isCorrect = (choice === positions[0][1]); 
            
            await showFeedback(isCorrect, 1000);
            
            // Hide demo title
            document.getElementById('demoTitle').style.display = 'none';
            
            // Show centered "Press Enter to Start Experiment" text
            document.getElementById('startExperimentText').style.display = 'block';
            
            // Wait for Enter key press
            await new Promise(resolve => {
                const handleKeyPress = (event) => {
                    if (event.key === 'Enter') {
                        document.removeEventListener('keydown', handleKeyPress);
                        document.getElementById('startExperimentText').style.display = 'none';
                        resolve();
                    }
                };
                document.addEventListener('keydown', handleKeyPress);
            });
        }
        
        // Main task flow
        async function startTask() {
            const participantNumber = document.getElementById('participantNumber').value;
            const age = document.getElementById('age').value;
            
            if (!participantNumber || !age) {
                alert('Please fill in all fields');
                return;
            }
            
            participantData.id = participantNumber;
            participantData.age = parseInt(age);
            
            document.getElementById('demographics').style.display = 'none';
            document.getElementById('taskContainer').style.display = 'block';
            
            // Wait for instructions
            await new Promise(resolve => {
                const handleKeyPress = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                    resolve();
                };
                document.addEventListener('keydown', handleKeyPress);
            });
            
            // Make task container fullscreen and hide instructions
            document.getElementById('taskContainer').classList.add('fullscreen');
            
            // Run demo trial first
            await runDemoTrial();
            
            // Start Block 1
            await runBlock1();
        }
        
        async function runBlock1() {
            const conditions = generateBlock1Conditions();
            block1Conditions = conditions; // Store conditions for output
            totalTrials = conditions.length;
            currentTrial = 0;


            for (let i = 0; i < conditions.length; i++) {
                currentTrial = i;
                updateProgress();
                
                await runBlock1Trial(conditions[i]);


                // Brief pause between trials
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            // Show break screen
            document.getElementById('taskContainer').style.display = 'none';
            document.getElementById('breakScreen').style.display = 'block';
        }
        
        async function continueToBlock2() {
            document.getElementById('breakScreen').style.display = 'none';
            document.getElementById('taskContainer').style.display = 'block';
            
            currentBlock = 2;
            await runBlock2();
        }
        
        async function runBlock2() {
            const conditions = generateBlock2Conditions();
            block2Conditions = conditions;
            totalTrials = conditions.length;
            currentTrial = 0;
            
            // Generate stimulus coordinates for Block 2
            const stimCoord = [];
            const stimSlope = [];
            const stimIntc = [];
            const stimDist = [];
            const stimDirX = [];
            
            
            for (let i = 0; i < conditions.length; i++) {
                const step = setStepDist[conditions[i][0]];
                const [m, c, coor] = genStimCoord(step);
                const direction = conditions[i][3];
                if (direction === 'backward') {
                    coor.reverse();
                    stimDirX.push('backward');
                } else {
                    stimDirX.push('forward');
                }
                
                stimDist.push(step);
                stimCoord.push(coor);
                stimSlope.push(m);
                stimIntc.push(c);
            }
            
            for (let i = 0; i < conditions.length; i++) {
                currentTrial = i;
                updateProgress();
                
                await runBlock2Trial(
                    conditions[i], stimCoord[i], stimSlope[i], 
                    stimIntc[i], stimDist[i], stimDirX[i]
                );
                
                // Brief pause between trials
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            // Task completed
            completeTask();
        }
        
        function completeTask() {
            // Prepare final data structure
            participantData.block1 = {
                data: block1Data,
                conditions: block1Conditions
            };
            participantData.block2 = {
                data: block2Data,
                conditions: block2Conditions
            };
            
            // Store data globally for download
            window.taskData = participantData;
            
            // Show completion screen
            document.getElementById('taskContainer').style.display = 'none';
            document.getElementById('completion').style.display = 'block';
        }
        
        function downloadData() {
            if (!window.taskData) {
                alert('No data available for download.');
                return;
            }
            
            // Create and download the JSON file
            const dataStr = JSON.stringify(window.taskData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${window.taskData.id}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Clean up
            URL.revokeObjectURL(url);
            
            // Update button to show completion
            const downloadBtn = document.getElementById('downloadData');
            downloadBtn.textContent = '✅ Data Downloaded!';
            downloadBtn.style.background = '#28a745';
            downloadBtn.disabled = true;
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Focus on first input
            document.getElementById('participantNumber').focus();
        });
    </script>
</body>
</html>
